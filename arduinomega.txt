#include <Keypad.h>
#include <Servo.h>
#include <SPI.h>
#include <MFRC522.h>
#include <LiquidCrystal.h>

// ------------------- COMMUNICATION PORTS -------------------
#define espSerial Serial1  // ESP32 on TX1(18), RX1(19)
#define gsmSerial Serial2  // SIM900 on TX2(16), RX2(17)

// ------------------- SYSTEM CONFIG -------------------
const String authorizedNumber = "+260970846745";  // Allowed sender
const String systemNumber = "+260981489062";      // Your SIM number
bool systemEnabled = true;                        // System status flag

// ------------------- DISPLAY STATES -------------------
enum DisplayState {
  MAIN_SCREEN,
  PIN_ENTRY,
  ACCESS_SCREEN
};
DisplayState currentDisplayState = MAIN_SCREEN;

// ------------------- KEYPAD CONFIG -------------------
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  { '1', '2', '3', 'A' },
  { '4', '5', '6', 'B' },
  { '7', '8', '9', 'C' },
  { '*', '0', '#', 'D' }
};
byte rowPins[ROWS] = { 22, 23, 24, 25 };
byte colPins[COLS] = { 26, 27, 28, 29 };
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// ------------------- HARDWARE CONFIG -------------------
const int buzzerPin = 42;
Servo gateServo;
const int servoPin = 2;
const int bulb1Pin = 40;  // Authorized (green)
const int bulb2Pin = 41;  // Unauthorized (red)
const int bulb3Pin = 43;  // System status indicator

// ------------------- LCD CONFIG -------------------
LiquidCrystal lcd(30, 31, 32, 33, 34, 35);  // RS, E, D4-D7

// ------------------- RFID CONFIG -------------------
#define SS_PIN 53
#define RST_PIN 5
MFRC522 mfrc522(SS_PIN, RST_PIN);
const String authorizedTag1 = "63 8D 75 DA";
const String authorizedTag2 = "CC 68 8A 3F";

// ------------------- SECURITY CONFIG -------------------
const String correctPIN = "5555";
String enteredPIN = "";
String currentSender = "";
float lastTemp = 0;
float lastHumidity = 0;
unsigned long lastAccessTime = 0;
const unsigned long accessScreenTimeout = 3000;  // 3 seconds

// GSM message buffer
String gsmBuffer = "";
unsigned long lastGSMCheck = 0;
const unsigned long gsmCheckInterval = 1000;

void setup() {
  // Initialize hardware
  pinMode(buzzerPin, OUTPUT);
  digitalWrite(buzzerPin, LOW);

  gateServo.attach(servoPin);
  gateServo.write(0);

  pinMode(bulb1Pin, OUTPUT);
  pinMode(bulb2Pin, OUTPUT);
  pinMode(bulb3Pin, OUTPUT);
  digitalWrite(bulb1Pin, LOW);
  digitalWrite(bulb2Pin, LOW);
  digitalWrite(bulb3Pin, systemEnabled ? HIGH : LOW);

  // Initialize displays
  lcd.begin(20, 4);
  lcd.print("System Booting...");

  // Initialize RFID
  SPI.begin();
  mfrc522.PCD_Init();

  // Initialize serial ports
  Serial.begin(9600);     // Debug console
  espSerial.begin(9600);  // ESP32
  gsmSerial.begin(9600);  // SIM900

  // Setup GSM
  setupGSM();

  lcd.setCursor(0, 1);
  lcd.print("Initializing GSM...");
  delay(2000);
  displayMainScreen();
}

void loop() {
  if (systemEnabled) {
    handleKeypad();
    handleRFID();
    handleSensorData();
  }

  // Check for GSM messages regularly
  if (millis() - lastGSMCheck > gsmCheckInterval) {
    handleGSM();
    lastGSMCheck = millis();
  }

  // Return to main screen after timeout
  if (currentDisplayState == ACCESS_SCREEN && millis() - lastAccessTime > accessScreenTimeout) {
    displayMainScreen();
  }

  delay(10);
}

// =================== DISPLAY FUNCTIONS ===================
void displayMainScreen() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Temp: ");
  lcd.print(lastTemp, 1);
  lcd.print("C");
  lcd.setCursor(0, 1);
  lcd.print("Hum:  ");
  lcd.print(lastHumidity, 1);
  lcd.print("%");
  lcd.setCursor(0, 2);
  lcd.print("System: ");
  lcd.print(systemEnabled ? "ENABLED" : "DISABLED");
  lcd.setCursor(0, 3);
  lcd.print("Press * for PIN");
  currentDisplayState = MAIN_SCREEN;
}

void displayPinEntryScreen() {
  if (!systemEnabled) {
    lcd.clear();
    lcd.print("SYSTEM DISABLED");
    lcd.setCursor(0, 1);
    lcd.print("Contact admin");
    beep(3, 200);
    delay(2000);
    displayMainScreen();
    return;
  }

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Enter PIN:");
  lcd.setCursor(0, 1);
  lcd.print("                ");  // Clear line for asterisks
  currentDisplayState = PIN_ENTRY;
}

// =================== GSM FUNCTIONS ===================
void setupGSM() {
  Serial.println("Initializing GSM Module...");

  // Reset module
  sendATCommand("AT+CFUN=1,1", "OK", 5000);
  delay(2000);

  // Basic initialization commands
  sendATCommand("AT", "OK", 2000);                  // Handshake
  sendATCommand("ATE0", "OK", 2000);                // Echo off
  sendATCommand("AT+CMGF=1", "OK", 2000);           // Text mode
  sendATCommand("AT+CNMI=1,2,0,0,0", "OK", 2000);   // New SMS notification
  sendATCommand("AT+CSMP=17,167,0,0", "OK", 1000);  // Text mode params
  sendATCommand("AT+CMGD=1,4", "OK", 2000);         // Delete all messages

  // Check signal quality
  String signal = sendATCommand("AT+CSQ", "OK", 1000);
  Serial.print("Signal quality: ");
  Serial.println(signal);

  Serial.println("GSM Module Ready");
}

String sendATCommand(String cmd, String ack, unsigned long timeout) {
  String response = "";
  gsmSerial.println(cmd);
  unsigned long startTime = millis();

  while (millis() - startTime < timeout) {
    while (gsmSerial.available()) {
      char c = gsmSerial.read();
      response += c;
      if (response.endsWith(ack)) {
        return response;
      }
    }
  }
  Serial.print("GSM Response: ");
  Serial.println(response);
  return response;
}

void handleGSM() {
  while (gsmSerial.available()) {
    char c = gsmSerial.read();
    gsmBuffer += c;

    // Check for complete message
    if (c == '\n' || gsmBuffer.length() > 200) {
      gsmBuffer.trim();
      Serial.print("GSM Received: ");
      Serial.println(gsmBuffer);

      if (gsmBuffer.startsWith("+CMT:")) {
        // Extract sender number
        int start = gsmBuffer.indexOf('"') + 1;
        int end = gsmBuffer.indexOf('"', start);
        currentSender = gsmBuffer.substring(start, end);
        Serial.print("Message from: ");
        Serial.println(currentSender);

        // Read message content (next line)
        unsigned long startTime = millis();
        String message = "";
        while (millis() - startTime < 1000) {
          if (gsmSerial.available()) {
            char m = gsmSerial.read();
            message += m;
            if (m == '\n') break;
          }
        }
        message.trim();
        Serial.print("Message content: ");
        Serial.println(message);

        if (currentSender == authorizedNumber) {
          processSMSCommand(message);
        } else {
          sendAutoReply("Unauthorized access blocked");
        }
      }
      gsmBuffer = "";  // Clear buffer
    }
  }
}

void updateSystemStatusIndicator() {
  digitalWrite(bulb3Pin, systemEnabled ? HIGH : LOW);
}

void processSMSCommand(String cmd) {
  cmd.toUpperCase();
  cmd.trim();

  Serial.print("Processing command: ");
  Serial.println(cmd);

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("SMS Command:");
  lcd.setCursor(0, 1);
  lcd.print(cmd);

  if (cmd == "DOOR OPEN") {
    if (systemEnabled) {
      grantAccess("SMS COMMAND");
      sendSMS(authorizedNumber, "GATE OPENED\nSystem: " + systemNumber);
    } else {
      sendSMS(authorizedNumber, "SYSTEM DISABLED\nCannot open gate\nSystem: " + systemNumber);
      lcd.setCursor(0, 2);
      lcd.print("SYSTEM DISABLED");
      beep(3, 100);
    }
  } 
  else if (cmd == "LIGHT ON") {
    if (systemEnabled) {
      lcd.clear();
      lcd.print("TURNING ON LIGHT");
      String payload = "{\"type\":\"command\",\"action\":\"light_on\"}";
      espSerial.println(payload);
      sendSMS(authorizedNumber, "LIGHT TURNED ON\nSystem: " + systemNumber);
      beep(1, 100);
    } else {
      sendSMS(authorizedNumber, "SYSTEM DISABLED\nCannot turn on light\nSystem: " + systemNumber);
      lcd.setCursor(0, 2);
      lcd.print("SYSTEM DISABLED");
      beep(3, 100);
    }
  }
  else if (cmd == "LIGHT OFF") {
    if (systemEnabled) {
      lcd.clear();
      lcd.print("TURNING OFF LIGHT");
      String payload = "{\"type\":\"command\",\"action\":\"light_off\"}";
      espSerial.println(payload);
      sendSMS(authorizedNumber, "LIGHT TURNED OFF\nSystem: " + systemNumber);
      beep(1, 100);
    } else {
      sendSMS(authorizedNumber, "SYSTEM DISABLED\nCannot turn off light\nSystem: " + systemNumber);
      lcd.setCursor(0, 2);
      lcd.print("SYSTEM DISABLED");
      beep(3, 100);
    }
  }
  else if (cmd == "OPEN DOOR WITH BULB ON") {
    if (systemEnabled) {
      lcd.clear();
      lcd.print("OPENING DOOR");
      lcd.setCursor(0, 1);
      lcd.print("BULB ON");

      digitalWrite(bulb1Pin, HIGH);
      moveServoGate();

      delay(3000);
      digitalWrite(bulb1Pin, LOW);

      sendSMS(authorizedNumber, "DOOR OPENED WITH BULB ON\nSystem: " + systemNumber);
    } else {
      sendSMS(authorizedNumber, "SYSTEM DISABLED\nCannot open gate\nSystem: " + systemNumber);
      lcd.setCursor(0, 2);
      lcd.print("SYSTEM DISABLED");
      beep(3, 100);
    }
  }
  else if (cmd == "SYSTEM STATUS") {
    String status = "SYSTEM STATUS\n";
    status += "Temp: " + String(lastTemp) + "C\n";
    status += "Humidity: " + String(lastHumidity) + "%\n";
    status += "Status: " + String(systemEnabled ? "ENABLED" : "DISABLED") + "\n";
    status += "System: " + systemNumber;
    sendSMS(authorizedNumber, status);
    lcd.setCursor(0, 2);
    lcd.print("STATUS SENT");
    beep(1, 100);
  }
  else if (cmd == "SYSTEM CLOSE") {
    systemEnabled = false;
    updateSystemStatusIndicator();
    sendSMS(authorizedNumber, "SYSTEM DISABLED\nSystem: " + systemNumber);
    lcd.setCursor(0, 2);
    lcd.print("SYSTEM DISABLED");
    beep(2, 200);
  }
  else if (cmd == "SEGUKA") {
    systemEnabled = true;
    updateSystemStatusIndicator();
    sendSMS(authorizedNumber, "SYSTEM ENABLED\nSystem: " + systemNumber);
    lcd.setCursor(0, 2);
    lcd.print("SYSTEM ENABLED");
    beep(1, 200);
  }
  else {
    sendSMS(authorizedNumber, "INVALID COMMAND\nValid: DOOR OPEN, LIGHT ON, LIGHT OFF, SYSTEM STATUS, SYSTEM CLOSE, SEGUKA\nSystem: " + systemNumber);
    lcd.setCursor(0, 2);
    lcd.print("INVALID COMMAND");
    beep(3, 100);
  }

  delay(2000);
  displayMainScreen();
}

void sendSMS(String number, String message) {
  Serial.print("Sending SMS to: ");
  Serial.println(number);
  Serial.print("Message: ");
  Serial.println(message);

  gsmSerial.print("AT+CMGS=\"");
  gsmSerial.print(number);
  gsmSerial.println("\"");
  delay(500);

  gsmSerial.print(message);
  delay(500);
  gsmSerial.write(26);  // CTRL+Z to send
  delay(1000);

  Serial.println("SMS sent");
}

void sendAutoReply(String message) {
  String fullMsg = "AUTO-REPLY\n";
  fullMsg += "From: " + systemNumber + "\n";
  fullMsg += message + "\n";
  fullMsg += "Time: " + getTimeStamp();
  sendSMS(currentSender, fullMsg);
}

// =================== KEYPAD FUNCTIONS ===================
void handleKeypad() {
  char key = keypad.getKey();

  if (key) {
    beep(1, 30);

    if (key == '#') {
      if (enteredPIN.length() == 0) {
        lcd.clear();
        lcd.print("NO PIN ENTERED");
        beep(2, 100);
        delay(1000);
        displayMainScreen();
      } else {
        String status = (enteredPIN == correctPIN) ? "granted" : "denied";
        String payload = "{\"type\":\"keypad\",\"status\":\"" + status + "\",\"pin\":\"" + enteredPIN + "\"}";
        espSerial.println(payload);

        if (enteredPIN == correctPIN) {
          grantAccess("KEYPAD");
        } else {
          denyAccess("WRONG PIN");
        }
        enteredPIN = "";
      }
    } else if (key == '*') {
      enteredPIN = "";
      displayPinEntryScreen();
    } else if (isdigit(key)) {
      if (currentDisplayState != PIN_ENTRY) {
        displayPinEntryScreen();
      }

      if (enteredPIN.length() < 6) {
        enteredPIN += key;
        lcd.setCursor(enteredPIN.length() - 1, 1);
        lcd.print("*");
      } else {
        beep(2, 50);
      }
    }
  }
}

// =================== RFID FUNCTIONS ===================
void handleRFID() {
  if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
    String uid = getUID();

    if (uid == authorizedTag1 || uid == authorizedTag2) {
      String payload = "{\"type\":\"rfid\",\"status\":\"granted\",\"tag\":\"" + uid + "\"}";
      espSerial.println(payload);
      grantAccess("RFID");
    } else {
      String payload = "{\"type\":\"rfid\",\"status\":\"denied\",\"tag\":\"" + uid + "\"}";
      espSerial.println(payload);
      denyAccess("INVALID TAG");
    }

    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
  }
}

String getUID() {
  String uid = "";
  for (byte i = 0; i < mfrc522.uid.size; i++) {
    if (mfrc522.uid.uidByte[i] < 0x10) uid += "0";
    uid += String(mfrc522.uid.uidByte[i], HEX);
    if (i < mfrc522.uid.size - 1) uid += " ";
  }
  uid.toUpperCase();
  return uid;
}

// =================== SENSOR FUNCTIONS ===================
void handleSensorData() {
  if (espSerial.available()) {
    String data = espSerial.readStringUntil('\n');
    data.trim();

    if (data.startsWith("{")) {
      lastTemp = parseValue(data, "temperature");
      lastHumidity = parseValue(data, "humidity");

      if (currentDisplayState == MAIN_SCREEN) {
        lcd.setCursor(6, 0);
        lcd.print(lastTemp, 1);
        lcd.print("C ");
        lcd.setCursor(6, 1);
        lcd.print(lastHumidity, 1);
        lcd.print("% ");
      }
    }
  }
}

// =================== ACCESS CONTROL ===================
void grantAccess(String method) {
  if (!systemEnabled) {
    lcd.clear();
    lcd.print("SYSTEM DISABLED");
    lcd.setCursor(0, 1);
    lcd.print("Contact admin");
    beep(6, 200);
    digitalWrite(bulb2Pin, HIGH);
    digitalWrite(bulb1Pin, LOW);
    delay(2000);
    digitalWrite(bulb1Pin, LOW);
    digitalWrite(bulb2Pin, LOW);
    displayMainScreen();
    return;
  }

  lcd.clear();
  lcd.print("ACCESS GRANTED");
  lcd.setCursor(0, 1);
  lcd.print(method);

  digitalWrite(bulb1Pin, HIGH);
  digitalWrite(bulb2Pin, LOW);
  beep(1, 100);
  delay(2000);
  digitalWrite(bulb1Pin, LOW);
  digitalWrite(bulb2Pin, LOW);
  moveServoGate();
  String logMsg = "ACCESS: " + method + "\nSystem: " + systemNumber;
  sendSMS(authorizedNumber, logMsg);

  currentDisplayState = ACCESS_SCREEN;
  lastAccessTime = millis();
}

void denyAccess(String reason) {
  lcd.clear();
  lcd.print("ACCESS DENIED");
  lcd.setCursor(0, 1);
  lcd.print(reason);

  digitalWrite(bulb1Pin, LOW);
  digitalWrite(bulb2Pin, HIGH);
  beep(3, 100);
  delay(2000);
  digitalWrite(bulb1Pin, LOW);
  digitalWrite(bulb2Pin, LOW);
  String logMsg = "DENIED: " + reason + "\nSystem: " + systemNumber;
  sendSMS(authorizedNumber, logMsg);
  currentDisplayState = ACCESS_SCREEN;
  lastAccessTime = millis();
}

// =================== UTILITY FUNCTIONS ===================
void moveServoGate() {
  if (!systemEnabled) return;

  // Open door
  gateServo.write(90);
  delay(5000);  // Keep door open for 5 seconds

  // Close door
  gateServo.write(0);
}

void beep(int times, int duration) {
  for (int i = 0; i < times; i++) {
    digitalWrite(buzzerPin, HIGH);
    delay(duration);
    digitalWrite(buzzerPin, LOW);
    delay(100);
  }
}

String getTimeStamp() {
  return String(millis() / 1000) + "s";
}

float parseValue(String json, String key) {
  int keyIndex = json.indexOf("\"" + key + "\":");
  if (keyIndex == -1) return 0;
  int colonIndex = json.indexOf(':', keyIndex);
  int commaIndex = json.indexOf(',', colonIndex + 1);
  if (commaIndex == -1) commaIndex = json.indexOf('}', colonIndex + 1);
  String value = json.substring(colonIndex + 1, commaIndex);
  value.trim();
  return value.toFloat();
}
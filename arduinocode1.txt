#include <WiFi.h>
#include <WebSocketsClient.h>
#include <HTTPClient.h>
#include <DHT.h>
#include <ArduinoJson.h>

// WiFi Configuration
const char* ssid = "Ben8";
const char* password = "flutters";

// Server Configuration
const char* websocket_server = "192.168.136.201";
const char* http_server = "192.168.136.201";
const uint16_t port = 3000;

// DHT Sensor
#define DHTPIN 4
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// Bulb Control
#define BULB_PIN 2
String bulbState = "off";

// Timers
const unsigned long sensorInterval = 5000;
unsigned long previousMillis = 0;
float currentTemp = 0;
float currentHumidity = 0;

WebSocketsClient webSocket;

void setup() {
  Serial.begin(115200);
  Serial2.begin(9600, SERIAL_8N1, 16, 17); // Communication with Mega

  pinMode(BULB_PIN, OUTPUT);
  digitalWrite(BULB_PIN, LOW);
  
  dht.begin();

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi Connected");

  // WebSocket setup
  webSocket.begin(websocket_server, port, "/");
  webSocket.onEvent(webSocketEvent);
  webSocket.setReconnectInterval(5000);
}

void loop() {
  webSocket.loop();

  // 1. Handle messages from Arduino Mega
  if (Serial2.available()) {
    String payload = Serial2.readStringUntil('\n');
    processMegaMessage(payload);
  }

  // 2. Read and send sensor data periodically
  if (millis() - previousMillis >= sensorInterval) {
    previousMillis = millis();
    readAndSendSensorData();
  }
}

void processMegaMessage(String payload) {
  payload.trim();
  Serial.println("From Mega: " + payload);

  // Parse JSON message
  StaticJsonDocument<200> doc;
  DeserializationError error = deserializeJson(doc, payload);
  
  if (!error) {
    // Handle bulb control commands
    if (doc.containsKey("action")) {
      String action = doc["action"].as<String>();
      if (action == "light_on") {
        setBulbState("on");
      } else if (action == "light_off") {
        setBulbState("off");
      }
    }
    // Handle other message types
    else if (doc.containsKey("type")) {
      String type = doc["type"].as<String>();
      if (type == "keypad") {
        sendKeypadEvent(payload);
      } 
      else if (type == "rfid") {
        sendRFIDEvent(payload);
      }
      else if (type == "sensor") {
        sendHTTPPost("/api/sensor-data", payload);
      }
    }
  }
}

void setBulbState(String newState) {
  if (newState != bulbState) {
    bulbState = newState;
    digitalWrite(BULB_PIN, (bulbState == "on") ? HIGH : LOW);
    
    // Send status updates
    sendBulbStatusToServer();
    sendBulbStatusToMega();
    
    Serial.println("Bulb state changed to: " + bulbState);
  }
}

void readAndSendSensorData() {
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  
  if (!isnan(h) && !isnan(t)) {
    currentTemp = t;
    currentHumidity = h;

    // Create JSON payload
    StaticJsonDocument<200> sensorDoc;
    sensorDoc["type"] = "sensor";
    sensorDoc["temperature"] = t;
    sensorDoc["humidity"] = h;
    sensorDoc["timestamp"] = millis()/1000;
    sensorDoc["datetime"] = getDateTime();
    sensorDoc["bulbState"] = bulbState;

    String sensorPayload;
    serializeJson(sensorDoc, sensorPayload);

    // Send to Node server
    sendHTTPPost("/api/sensor-data", sensorPayload);
    
    // Also send to Mega
    Serial2.println(sensorPayload);
  }
}

void sendKeypadEvent(String payload) {
  sendHTTPPost("/api/keypad-events", payload);
}

void sendRFIDEvent(String payload) {
  StaticJsonDocument<200> doc;
  DeserializationError error = deserializeJson(doc, payload);
  
  if (!error) {
    String status = doc["status"];
    String tag = doc["tag"];
    
    String rfidPayload = "{\"status\":\"" + status + " access\",\"tag\":\"" + tag + "\"}";
    sendHTTPPost("/api/rfid-event", rfidPayload);
  }
}

void sendBulbStatusToServer() {
  StaticJsonDocument<100> doc;
  doc["type"] = "bulb_status";
  doc["state"] = bulbState;
  
  String payload;
  serializeJson(doc, payload);
  webSocket.sendTXT(payload);
}

void sendBulbStatusToMega() {
  StaticJsonDocument<100> doc;
  doc["type"] = "status";
  doc["light"] = bulbState;
  
  String payload;
  serializeJson(doc, payload);
  Serial2.println(payload);
}

void sendHTTPPost(String endpoint, String payload) {
  HTTPClient http;
  http.begin("http://" + String(http_server) + ":" + port + endpoint);
  http.addHeader("Content-Type", "application/json");
  
  int httpCode = http.POST(payload);
  if (httpCode > 0) {
    Serial.printf("[HTTP] POST to %s: %d\n", endpoint.c_str(), httpCode);
  } else {
    Serial.printf("[HTTP] POST failed, error: %s\n", http.errorToString(httpCode).c_str());
  }
  http.end();
}

String getDateTime() {
  // Placeholder - implement with NTP in production
  return "2023-01-01T00:00:00Z";
}

void webSocketEvent(WStype_t type, uint8_t* payload, size_t length) {
  // Variables declared outside switch to avoid cross-initialization
  StaticJsonDocument<200> doc;
  DeserializationError error;
  String message;
  String cmd;

  switch (type) {
    case WStype_DISCONNECTED:
      Serial.println("[WS] Disconnected");
      break;
      
    case WStype_CONNECTED:
      Serial.println("[WS] Connected");
      sendBulbStatusToServer(); // Sync current bulb state
      break;
      
    case WStype_TEXT:
      message = (char*)payload;
      Serial.println("[WS] Received: " + message);
      
      error = deserializeJson(doc, message);
      if (!error && doc.containsKey("command")) {
        cmd = doc["command"].as<String>();
        if (cmd == "light_on") {
          setBulbState("on");
        } else if (cmd == "light_off") {
          setBulbState("off");
        }
      }
      break;
      
    case WStype_ERROR:
      Serial.printf("[WS] Error: %u\n", *payload);
      break;
  }
}